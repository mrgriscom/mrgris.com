--- 
title: Minesweepr
thumb: minesweepr.png
style: project
---

<% content_for :lede do %>
<p>
A minesweeper solver in python. Exhaustively solves any board, of any topology, through the use of advanced combinatorial and probability analysis. Can compute the exact mine probabilities of all 'ambiguous' cells, and can detect inconsistent game states. While highly optimized, ultimately still an <i>O(k<sup>n</sup>)</i> algorithm. Includes a live web demo.
</p>

<p class="li"><%= link_to('Read more&hellip;', @item) %></p>
<% end %>

<!-- table needed so sidebar div will extend full vertical length of content -->
<table id="mnswmain">
<tr>

<td id="mnswcontent">

<h3>What is this?</h3>

<p>
This project is a general minesweeper solver. It can solve any game board, with any <a href="#topology">topology</a>, and compute the exact mine probabilities for all cells. It achieves this through advanced combinatorial and probability analysis.
</p>

<h3>How does it work?</h3>

<p>
Essentially, a minesweeper board is a set of logical constraints. Each cell is a toggle with two possible states: mine or clear. Each uncovered cell is a statement about how many of the adjacent cells are mines. Our goal is to find configurations of mines that satisfy the given constraints. If, among all possible configurations, a given cell is always a mine or always clear, we know that mine is safe to mark or sweep, respectively. If the cell can be either state, depending on configuration, we cannot determine its status with certainty; however, we <em>can</em> compute its relative safety by observing how many configurations in which it appears empty, as a proportion of all possible configurations, <em>assuming all configurations are equally likely</em>. If there is no guaranteed-safe cell, we can still determine the safest cell to sweep, and thus play minesweeper with considerable skill.
</p>

<p>
Any algorithm that hopes to exhaustively<%= footinline(1) %> solve minesweeper must employ this basic concept: determine all possible placements of mines on the board (and the relative likelihoods thereof), and observe how often each cell has a mine in it. This is easier said than done. To naively enumerate all possible mine configurations is hugely expensive&mdash; an exponential-time algorithm<%= footinline(2) %>. This solver employs a <a href="#TODO-algodetails">number of techniques</a> to cut down on the amount of work needed.
</p>

<a name="foot1">
<p class="footend">
<span class="footmark">*</span> meaning it can determine the best move on all possible boards, even when no cell is 100% safe and the best move requires guessing
</p>
</a>

<a name="foot2">
<p class="footend">
<span class="footmark">&dagger;</span> meaning for any fixed amount you increase the size of the problem by (e.g., 10 more cells on the board), the amount of computational work to solve it doubles; translated: <em>the universe will freeze over before your computer finishes</em>. How big the exponent determines how quickly the work balloons out of control.
</p>
</a>

<p>
The unfortunate truth, however, is that despite all these advanced tricks and analyses, <em>minesweepr</em> still requires exponential time to run &mdash; each additional technique only shaves some amount off that exponent. <a href="http://for.mat.bham.ac.uk/R.W.Kaye/minesw/ordmsw.htm">It is strongly suspected</a> that exponential time is the best we can do. Luckily, in practice, the exponent and board size are together small enough that boards can be solved <a href="#TODO-runtime">quickly</a>.
</p>

<p>
The <em>real</em> truth is even worse than that. This algorithm only computes the optimal cell for the very next move. To have the best chance of finishing the game, we must consider not only the next move but all future moves. Is there a difference? Yes!
</p>

<p>
Assume we're stuck in a situation where we have to guess: imagine we make the 'best' next move by clicking on the safest cell. This doesn't reveal much new information about the remaining cells, but at least we're still alive. So we click on the (new) safest cell again, and again&hellip; finally we get some information that removes the remaining uncertainty and lets us escape from whatever corner we're trapped in.
</p>

<p>
Now suppose there was a riskier<%= footinline(3) %> cell that, had we clicked on it and lived, would have removed that uncertainty right away. It's possible that we exposed ourselves to more accumulated risk by taking the conservative route of making multiple less-risky moves, rather than making the single, bold move up front. There are known examples of this situation. And while I can't prove it, anecdotally, the safer bets do indeed seem to reveal less information about the remaining cells than do riskier<%= footinline(4) %>.
</p>

<a name="foot3">
<p class="footend">
<span class="footmark">&#x2021;</span> note, astute reader, that 'riskier' in this context means the most uncertain &mdash; closest to 50/50 &mdash; <em>not</em> the most likely to kill you
</p>
</a>

<a name="foot4">
<p class="footend">
<span class="footmark">&sect;</span> another example is the popular strategy of clicking in the uncharted regions of the board in the hopes of getting a "cascade", i.e., opening up a new front of play, even though the uncharted region is typically risky. Is this a more viable long-term strategy than carefully extricating yourself in the manner described above? I have no idea. But it's an important question, as it changes the fundamental character of how the board is solved.
</p>
</a>

<p>
So the safest move at the moment is not always the best move for long-term success. To create a perfect player that accounts for this &mdash; the outcome not just of this move, but the repurcussions of all possible subsequent moves &mdash; is intractable. Solving minesweeper is generally <em>hard</em>. Looking several moves ahead may be feasible, and pay off enough to be worth it (particularly during the endgame), but this algorithm doesn't concern itself with that. And the open-ended case, for "perfect" play, simply cannot be done.
</p>

<p>
Nevertheless, it's fun to watch the algorithm working even one move ahead. It's almost uncannily adept at getting out of tight situations.
</p>

<a name="topology"><h3>"any topology"</h3></a>

<p>
The normal minesweeper layout is a basic grid. However, this solver can handle many unconventional layouts, such as minesweeper on a non-flat/closed surface, in 3-d, or with non-square cells. And it can do so without any change whatsoever to the basic algorithm.
</p>

<p>
Because the solver deals only in logical predicates of how many mines are to be found among given sets of cells, it actually has no concept of which cells are "next" to each other, or of the topology of the board at all. The game driver is responsible for defining and tracking the adjacency of cells. <em>Minesweeper</em> knows of the board state only as an abstraction; as to whether the board contains wrapping edges, miscellaneous warps or holes, odd shapes or extra dimensions, <em>minesweepr</em> remains ignorant, and solves them all alike.
</p>

<h3>Failure Modes</h3>

failure modes
interconnectedness - more permutations and less deduction
long branches
undivinable

works best when can take advantage of deductive logic

<h3>How good is it?</h3>

[insert solving probability]

</td>

<td>
<table id="mnswsidebar">

<tr>
<td class="sidebarbg" style="height: 150px;">
<table><tr><td>&nbsp;</td></tr></table>
</td>
</tr>

<tr>
<td style="height: 1px; padding: 35px 0;">

<a class="button" href="#">Live Demo</a>
<a class="button" href="#">Board Solver</a>
<a class="button" href="#">The Algorithm</a>

</td>
</tr>

<tr>
<td class="sidebarbg">
<table><tr><td>&nbsp;</td></tr></table>
</td>
</tr>

</table>
</td>

</tr>
</table>

